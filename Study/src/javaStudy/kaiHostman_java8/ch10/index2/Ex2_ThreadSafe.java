package javaStudy.kaiHostman_java8.ch10.index2;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class Ex2_ThreadSafe {
	// 병행 프로그래밍에서 잘못되는 부분, 대비할 수 있는 내용을 소개
	
	
	public static void main(String[] args) {
//		가시성();
		경쟁();
		
	}
	
	/** ---------------------------------------
	 	-- 1. 가시성
	 	--------------------------------------- */
	private static volatile boolean done;
//	private static boolean done; 	// volatile 적용 전(문제...)
	public static void 가시성() {
		/* 변수 업데이트가 보이게 보장하는 방법
		 * 1. final 변수의 값은 초기화 후에 보인다.
		 * 2. static 변수의 초깃값은 정적 초기화 후에 보인다.
		 * 3. volatile 변수의 변경은 보인다.
		 * 4. 잠금을 해제하기 전에 일어나는 변경은 같은 잠금을 획득하는 쪽에 보인다.
		 */
		System.out.println("가시성 start");
		Runnable r1 = ()->{
			for (int i = 0; i < 1000; i++) {
				if (i%100==0) System.out.println(i); 
//				if (i%10==0) System.out.println(i); 
			}
			done = true;
		};
		
		Runnable r2 = ()->{
			int i = 1;
			while(!done) i++; 
			
			System.out.println("bye~"+i);
		};
		Executor exe = Executors.newCachedThreadPool();
		exe.execute(r1);
		exe.execute(r2);
		System.out.println("가시성 end");
	} 
	
	 
	/** ---------------------------------------
	 	-- 2. 경쟁(공유 자원)
	 	--------------------------------------- */
	// 병행 테스크 여러개가 공유하는 정수 카운터를 업데이트하는 예제
	// 100 * 1000 -> 결과 값이 100000 이 안나옴, 출력 순서도 순서가 뒤죽박죽임
	// -> 공유 변수가 변경될 때마다 일어나는 문제이다.
	// -> 해결) 잠금을 이용하여 임계적인 연산을 원자적으로 만드는 것 -> 주의사항> 퍼포먼스 저하 & 교착상태 야기 가능성있음	 
	private static volatile int shareInt = 0;
	public static void 경쟁() {
		int loopConst = 100;
		int threadConst = 1000;
		for (int i = 0; i < loopConst; i++) {
			int taskId = i;
			Runnable r = () -> {
				for (int j = 0; j < threadConst; j++) {
					shareInt++;
				}
				System.out.println(taskId+" : "+shareInt);
			};
			Executors.newCachedThreadPool().execute(r);
		}
	}
	
	/** ---------------------------------------
	 	-- 3. 안전한 병행성을 실현히는 전략
	 	--------------------------------------- */
	/*
	 * 안전한 병행성 실현 전략
	 * 3.1) 가두기
	 * 그런데 여러 태스크 사이에서 데이터를 공유해야 하는 상황에는 이 지침을 따르지 말자. 
	 * 예를 들어 테스크에서 뭔가를 세야 할 때는 공유 카운터를 업데이트하는 대신 각 테스크에 비공개 카운터를 제공한다.
	 * 그리고 테스크가 완료될 때는 결과들을 결합하는 또 다른 테스크에 각각의 결과를 전달하게 하면 된다. 
	 *
	 * 3.2) 불변성
	 * 불변객체를 공유하는 것은 안전하다. 이를테면 테스크에서 결과를 공유 컬렉션에 추가하는 대신, 결과로 구성된 불변 컬렉션을 만들 수 있다.
	 * 그리고, 또다른 테스크는 결과들을 또 다른 불변 자료 구조로 결합한다. -> *몇가지 주의사항 존재 
	 * 
	 * 3.3) 잠금설정
	 * 한 번에 한 테스크에만 자료 구조에 접근할 수 있는 권한을 주는 방법이다. -> 병렬성 기회를 줄여주기때문에 자원소모가 클 수 있다.
	 * 예를 들어, 결과를 공유 해시테이블에 넣는 테스크가 많을때는 업데이트가 수행될때마다 해당 해시 테이블이 잠긴다. 바로 이 분분이 실제 병목 지점이다.
	 * 테스크 대부분이 자신의 차례를 기다려야하는 상황에서는 유용한 일을 하지 않는다. 
	 * 때로는 데이터를 나눠서(partitioning) 동시에 서로 다른 조각이 접근할 수 있게 할 수도 있다.
	 * 그리고 자바에서 제공하는 라이브러리와 자료구조를 잘 사용하자. -> 자바 병행성 라이브러리... 스트림 라이브러리의 병렬알고리즘처럼 파티셔닝을 이용
	 */

	
	/** ---------------------------------------
	 	-- 4. 불변 클래스
	 	--------------------------------------- */
	/* 한 번 인스턴스를 생성하고나서 변경할 수 없는 클래스는 불변클래스이다.
	 * 다른 예로 결과를 모으는데 사용할 집합이 있다고 가정하자. 이때는 가변 HashSet을 이용하여 다음과 같이 업데이트 할 수 있다.
	 * results.addAll(newResults);
	 * 이러면 위험하다...
	 * 
	 * 불변 집합은 항상 새로운 집합을 생성한다. 위의 코드 대신 아래의 코드로 수정하자.
	 * results = results.union(newResults);
	 * 
	 * 여전히 변경은 일어나지만, 많은 메소드가 포함된 해시 집합보다는 변수 하나에 일어나는 일을 제어하는게 더 쉽다.
	 * 
	 * 불변 클래스를 사용할때 주의사항>
	 * 1. 인스턴스 변수를 final로 선언해야한다.
	 * -> 가상머신은 final 인스턴스 변수가 생성된 후에 이것이 보이도록 보장한다.
	 * 
	 * 2. 어떤 메소드도 변경자가 될 수 없다. -> 메소드를 final로 만들거나, 클래스를 final로 선언해서 해당 메소드를 변경자로 오버라이드 방지하게한다.
	 * 
	 * 3. 가변 상태를 유출하지 않아야한다.
	 * 어떤 메소드도 변경용으로 이용할 수있는 내부 참조를 반환할 수 없다. 또한, 
	 * 메소드 중 하나가 또다른 클래스의 메소드를 호출할때도 이런 참조를 전달하지 말아야한다.
	 * 
	 * 4.생성자에서 this 참조를 노출하지 않아야한다.
	 * 또 다른 메소드를 호출할 때 내부 참조를 전달하지 말아야 한다... this라면 this는 생성후에는 안전하다.
	 * 하지만, 생성자 안에서 this를 노출하면 누군가는 객체가 불완전한 상태에 놓인 상황을 관찰할 수 있다.
	 *
	 *  
	 */
	
	
}
