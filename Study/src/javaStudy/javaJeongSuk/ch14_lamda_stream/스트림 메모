[스트림]

1. 배경
	
	 스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 매소드들을 정의했다.
	데이터 소스(컬렉션, 배열, 파일 등)의 추상화는 데이터 소스가 무엇이든 같은 방식으로 다룰 수 있고, 
	코드의 재사용성이 높다는 것을 의미한다.
	
	ex.1) 데이터 소스를 다루는 방법을 jdk 8 이전 방식과 stream을 이용한 방식의 차이를 알아보자
		String[] strArr = {"aaa", "bbb", "ccc"};
		List<String> strList = Arrays.asList(strArr);
		
		Array.sort(strArra);
		for(String str : strArr)
			System.out.println(str);
				
		Collections.sort(strList);
		for(String str : strList)
			System.out.println(str);
		
		
		위의 두 데이터 소스를 스트림으로 생성 및 정렬/출력하는 방법은 아래와 같다.
		-> Stream<String> strStream1 = strList.stream();
		-> Stream<String> strStream2 = Arrays.stream(strArr);
		
		-> strStream1.sorted().forEach(System.out::println);
		-> strStream2.sorted().forEach(System.out::println);
	
	※ 유의사항
	
	1) 스트림은 데이터 소스를 변경하지 않는다.
	 스트림은 데이터 소스로 부터 데이터를 읽기만 할 뿐 데이터 소스를 변경하지 않는다. 
	필요하다면 정렬된 결과를 컬렉션이나 배열에 담아 반환할 수도 있다.
	 
	 ex) List<String> sortedList = strStream2.sorted().collect(Collections.toList());
	 
	2) 스트림은 일회용이다.
	 스트림은 iterator와 같이 일회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼
	스트림도 한번 사용하면 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다.
	 
	 ex) 
	  strStream1.sorted().forEach(System.out::println);
	  int numOfStr = strStream1.count(); // 에러 -> 이미 스트림을 사용하여 닫혔음
	
	3) 스트림은 작업을 내부 반복으로 처리한다.
	 스트림을 이용한 작업이 간결할 수 있는 비결 중의 하나가 '내부 반복'이다.
	내부 반복은 반복문을 메소드 내부에 숨길 수 있다는 것이다.
	forEach()는 스트림에 정의된 메소드 중에 하나의 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.
	즉, forEach()는 메소드 내에 for문을 넣은것이고, 수행할 작업은 매개변수로 받는다.
	 
	 void forEach(Consumer<? super T> action){
	 	Objects.requireNonNull(action); // null chk
	 	for(T t : src) action.accept(T);
	 }


2. 연산(operation)

	 스트림의 연산은 중간, 최종연산으로 나뉜다. 
	중간연산은 연산결과를 스트림을 반환하기 때문에 중간 연산을 연속해서 연결할 수 있지만, 
	최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한 번만 연산이 가능하다.
	(※ 모든 중간연산의 결과는 스트림이지만, 연산 전의 스트림과 동일하지 않다.)
	
	ex) stream.distinct().limit(5).sorted().forEach(System.out::println);
		-> forEach()전까지 중간연산, 이후로는 최종연산
	
	<중간연산> -> map, flatMap 중요
		Stream<T> distinct() 										| 중복 요소 제거
		Stream<T> filter(Predicate<T> predicate) 					| 조건에 안 맞는 요소 제외
		Stream<T> limit(long maxSize) 								| 스트림 요소의 갯수를 일부만(size개) 잘라낸다.
		Stream<T> skip(long n) 										| 스트림 요소의 갯수를 일부만(size개) 건너뛴다.
		Stream<T> sorted(), sorted(Consumer<T> action)				| 스트림 요소 정렬
		Stream<T> peek(Consumer<T> action) 							| 스트림 요소 대상으로 작업 수행
		
		map*(..)													| 스트림의 요소를 변환, 작업
		Stream<R> map(Function<T,R> mapper) 						
		DoubleStream mapToDouble(ToDoubleFunction<T> mapper) 		
		IntStream mapToInt(ToIntFunction<T> mapper)
		LongStream mapToLong(ToLongFunction<T> mapper)
		
		flatMap*(..) 												| 스트림의 요소를 변환, 작업
		Stream<R> flatMap(Function<T,Stream<R>> mapper)
		DoubleStream flatMapToDouble(ToDoubleFunction<T, DoubleStream> mapper) 		
		IntStream flatMapToInt(ToIntFunction<T, IntStream> mapper) 		
		LongStream flatMapToLong(ToLongFunction<T, LongStream> mapper) 		
	
	
	<최종 연산> -> reduce, collect 중요
		void forEach(Consumer<? super T> action)			| 각 요소에 지정된 작업 수행
		void forEachOrdered(Consumer<? super T> action)		| 각 요소에 지정된 작업 수행
		long count()										| 스트림 요소의 개수 반환
		Optional<T> max(Comparator<? super T> comparator)	| 스트림의 최대값 반환
		Optional<T> min(Comparator<? super T> comparator)	| 스트림의 최소값 반환
		Optional<T> findAny()								| 스트림의 요소 하나 반환(아무거나 하나의 요소)
		Optional<T> findFirst()								| 스트림의 요소 하나 반환(첫 번째 요소)
		
		boolean allMatch(Predicate<T> p)					| 주어진 조건을 모든 요소가 만족하는지 chk
		boolean anyMatch(Predicate<T> p)					| 주어진 조건을 요소 하나라도 만족하는지 chk
		boolean noneMatch(Predicate<T> p)					| 주어진 조건을 모든 요소가 만족하지 않는지 chk
		
		Object[] toArray()									| 스트림의 모든 요소를 배열로 반환
		A[] toArray(IntFunction<A[]> generator)				| 스트림의 모든 요소를 배열로 반환
		
		Optional<T> reduce(BinaryOperator<T> accumulator)   | 스트림의 요소를 하나씩 줄여가며(리듀싱) 계산한다.
		T reduce(T identity, BinaryOperator<T> accumulator) | 스트림의 요소를 하나씩 줄여가며(리듀싱) 계산한다.
		U reduce(U identity,								| 스트림의 요소를 하나씩 줄여가며(리듀싱) 계산한다. 
				BiFunction<U,T,U> accumulator, 
				BinaryOperator<U> combiner) 
		
		R collect(Collector<T,A,R> collector) 				| 스트림의 요소 수집, 주로 요소를 그룹화, 분할한  
															  결과를 컬렉션에 담아 반환할때 사용
		R collect(Supplier<R> supplier,						 
				  BiConsumer<R,T> accmulator, 
				  BiConsumer<R,R> combiner) 				| 스트림의 요소 수집, 주로 요소를 그룹화, 분할한  
															  결과를 컬렉션에 담아 반환할때 사용
															  
	- 지연된 연산
	 스트림 연산에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지 중간연산이 수행되지 않는다는 것이다.
	 (-> 스트림에 대해 distinct(), sorted() 같은 중간 연산을 호출해도 즉각적인 연산이 수행되지 않음)
	중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이며, 
	최종연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.
	
	- Stream<Integer>와 IntStream 차이
	 요소의 타입이 T인 스트림은 기본적으로 Stream<T>이지만 오토박싱&언박싱으로 인한 비효율을 줄이기 위해 
	데이터 소스의 요소를 기본형으로 다루는 스트림, IntStream, Long..., Double...이 제공된다.
	일반적으로 Stream<Integer>대신 IntStream을 사용한것이 더 효율적이며, 
	IntStream에는 int 타입의 값으로 작업하는데 있어 유용한 메소드들이 포함되어있다.
	
	- 병렬 스트림
	 스트림으로 데이터 처리 시 병렬 처리가 쉽다는 장점이 있다. 
	스레드의 join&fork 프레임워크로  작업을 병렬처리를 할 수 있었다. 
	병렬 스트림은 내부적으로 이 프레임웍을 이용해서 자동적으로 연산을 병렬로 수행한다. 
	병렬 스트림을 위해서 사용자는 일반 스트림 대신 parallelStream()을 호출하면 된다. 
	반대로, 병렬처리를 하지 않기(병렬처리 취소) 위해서는 sequential()을 호출하면 된다.
	
	ex) int sum = strStream.parallelStream().mapToInt(s->s.length()).sum(); 


3. 스트림 생성
	
	- 컬렉션
	컬렉션의 최고 조상인 Collection에 stream이 정의되어 있다. 따라서 List, Set을 구현한 클래스는 
	모두 stream을 생성할 수 있다.
	stream()은 해당 컬렉션을 소스로하는 스트림을 반환한다.
 
	ex)	List<Integer> list = Arrays.asList(1,2,3,4,5);  // 가변인자
		Stream<Integer> intStream = list.stream();		// list를 소스로 하는 컬렉션 생성
		
	forEach()는 지정된 작업을 스트림의 모든 요소에 대해 수행한다(데이터 소스를 소모 X, 생성된 스트림의 요소 사용 O).
	intStream.forEach(System.out::println); 			// intStream 모든 요소 출력, 스트림 한번만 사용 가능
	
	- 배열
	배열을 데이터 소스로 스트림을 생성하는 메소드는 Stream과 Arrays에 static 메소드로 정의되어있다.
	Stream<T> Stream.of(T... values) // 가변인자 // ex) Stream<String> exStream = Stream.of("a","b","c"); 
	Stream<T> Stream.of(T[]) 		 			 // ex) Stream<String> exStream = Stream.of(new Stringp[]{"a","b","c"});
	Stream<T> Arrays.stream(T[])				 // ex) Stream<String> exStream = Arrays.stream(new Stringp[]{"a","b","c"});
	Stream<T> Arrays.stream(T[] array, int startIndex, int endIndex)
	
	IntStream IntStream.of(int... values || int[])	 
	IntStream Arrys.stream(int[])
	
	- 특정 범위의 정수
	IntStream, LongStream은 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 range(), rangeClosed()를 갖고 있다.
	IntStream  IntStream.range(int begin, int end) 			// IntStream intStream = range(1, 5)      -> 1,2,3,4
	IntStream  IntStream.rangeClosed(int begin, int end)	// IntStream intStream = rangeClosed(1,5) -> 1,2,3,4,5
	
	- 임의의 수
	난수 생성 시 사용하는 Random 클래스에는 int, long, double 타입의 나수로 이루어진 스트림을 반환한다.
	
	※ 난수 생성 메소드는 크기 제한이 없는 무한 스트림을 발생시키기 때문에 limit() 혹은 매개변수를 통해 크기를 제한해줘야한다.
	ex) IntStream randomlyIntStream = new Random().ints().limit(10).forEach(System.out::println); // 10개 난수 스트림
		IntStream randomlyIntStream = new Random().ints(10).forEach(System.out::println);	// 10개 난수 스트림
		IntStream randomlyIntStream = new Random().ints(1,5).forEach(System.out::println);  // [1,4] 내의 난수 스트림
		
	- 람다식 : iterate(), generate()
	Stream 클래스의 iterate(), generate()는 람다식을 매개변수로 받아서
	람다식에 의해 계산되는 결과를 요소로하는 무한 스트림을 생성한다.
	
	static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
	-> iterate()는 씨앗값(seed)로 지정된 값부터 시작하여 람다식 f에 의해 
	   계산된 결과를 다시 seed값으로 해서 계산을 반복한다.
		
	ex) 아래의 evenStream은 0부터 시작해서 값이 2씩 증가한다.
		Stream<Integer> evenStream = Stream.iterate(0, n->n+2); // 0, 2, 4, 6, ...
		   
	static <T> Stream<T> generate(Supplier<T> s)
	-> generate도 iterate()와 같이, 람다식에 의해 계산되는 값을 요소로 하는 무한스트림을 생성하지만, 
	   iterate()와는 달리 이전 결과를 다음 요소의 소스(seed)로 사용하지 않는다.
	   
	   또한, generate()의 매개변수의 타입은 Supplier<T> 이므로 매개변수가 없는 람다식만 허용된다.
	   한 가지 주의점은 iterate()와 generate()에 의해 생성된 스트림을 
	   아래와 같이 기본형 스트림 타입의 참조변수로 다룰 수 없다. 

	   IntStream evenStream = Stream.iterate(0, n->n+2); 
	   // 에러	-> Stream<Integer>로 받거나 OR .mapToInt(Integer::valueOf)로 후처리 필요
	   // IntStream 타입의 스트림을 Stream<Integer>로 타입변환하려면 boxed()를 사용하자(IntStream->Stream<Integer>)

	   DoubleStream randomStream = Stream.generate(Math::random); // 에러 -> Stream<Double>로 받아야 할듯

	- 파일
	java.nio.file.Files는 파일을 다루는데 유용한 여러 메소드를 제공한다. 
	list()의 경우 지정된 디렉토리의 파일 목록을 소스로하는 스트림을 반환한다. ex) Stream<Path> File.list(Path dir)
	
	파일의 한 행을 요소로하는 스트림을 생성하는 메소드 BufferedReader 클래스의 Stream<String> lines() 
	
	- 빈 스트림
	요소가 없는 빈 스트림 생성하며, 스트림에 연산 수행 결과가 하나도 없을때 null 대신 빈 스트림을 반환할 때 유용하다
	Stream emptyStream = Streama.empty();  // empty는 빈 스트림을 생성해서 반환한다.
	long count = emptyStream.count();	   // 0 반환
	
	- 두 스트림 연결
	Stream의 static 메소드인 concat()은 두 스트림을 하나로 연결할 수 있다. 이때 두 스트림의 요소는 동일한 타입이어야한다.
	String[] str1 = {"123", "444", "567"};
	String[] str2 = {"abc", "ddd", "fea"};
	
	Stream<String> strStream1 = Stream.of(str1);
	Stream<String> strStream2 = Stream.of(str2);
	Stream<String> strStream3 = Stream.concat(str1, str2);
	

4. 스트림 중간 연산
	------------------------------------------------------------------------------------------------------------------------
	
	◈◈◈ 스트림 자르기 : skip(), limit()
	skip(a)  : 처음 a개의 요소를 건너뛴 요소를 스트림에 담아 반환한다.
	limit(a) : 요소의 갯수를 a로 제한한 스트림을 반환
	
	ex) IntStream intStream = IntStream.range(1,10);
		intStream.skip(3).limit(5).forEach(System.out::println); // 4,5,6,7,8 요소 출력
	
	------------------------------------------------------------------------------------------------------------------------
			
	- 스트림의 요소 걸러내기 : filter(), distinct()
	distinct()는 스트림에서 중복된 요소들을 제거하고, fiter()는 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다.
	
	ex) IntStream intStream = IntStream.of(1,2,2,5,5,5,6,6,6,7,7);
		intStream.distinct().forEach(System.out::println); 			// 1,2,5,6,7
		
	filter()는 매개변수로 Predicate를 필요하다. 아래와 같이 연산 결과가 boolean인 람다식을 사용해도 된다.
	ex) IntStream intStream = IntStream.rangeClosed(1,10); 			// 1~10
		intStream.filter(i->i%2==0).forEach(System.out::println); 	// 2,4,6,8,10
		
		// filter를 여러번 적용할 수 있음 or 다중 조건을 적용할 수도 있음
		intStream.filter(i->i%2==0).filter(i->i%3==0).forEach(System.out::println); // 6
		intStream.filter(i->i%2==0 && i%3==0).forEach(System.out::println); 		// 6
	
	------------------------------------------------------------------------------------------------------------------------
	
	◈◈◈ 정렬 : sorted()
	sorted()는 지정된 Comparator로 스트림을 정렬하는데, Comparator 대신 int 값을 반환하는 람다식으로도 사용할 수 있다.
	Comparator를 지정하지 않으면 스트림 요소의 기본 정렬기준(Comparable)로 정렬한다.
	단, 스트림의 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.
	
	ex) Stream<String> strStream = Stream.of("dd", "aa", "cc", "AA", "e");
	strStream.sorted().forEach(System.out::print); AAaaccdde
	
	※ 자바의 정석 p824~826 -> sorted 기준으로 사용할 수 있는 comparator 인터이스의 다양한 메소드 소개
	ex) exampleStream.sorted(Comparator.comparing(Student::name)
										.thenComparing(Student::number)
										.thenComparing(Student::height)).forEach(System.out::println);
										
	------------------------------------------------------------------------------------------------------------------------
	
	◈◈◈ 변환 : map()
	스트림의 요소에 저장된 값 중에서, 원하는 필드만 뽑아내거나, 특정 형태로 변환해야 할 때가 있다. 
	이 때 사용하는 것이 바로 map()이다. 이 메소드의 선언부는 아래와 같으며, 
	매개변수로 T타입 R타입으로 변환해서 반환하는 함수를 지정해야한다.

		Stream<R> map(Function<? super T, ? extends R> mapper)

	예를 들어 File의 스트림에서 파일의 이름만 뽑아서 출력하고 싶을 때, 
	아래와 같이 map()을 이용하면 File 객체에서 파일의 이름(String)만 간단히 뽑아낼 수 있다.
	
		ex) Stream<File> fileStream = Stream.of(new File("Ex1.java"), new File("Ex1"), 
										new File("Ex1.bak"), new File("Ex2.java"), new File("Ex1.txt"));

	map() 역시 중간 연산자이므로, 연산결과는 String을 요소로하는 스트림이다. 
	map()으로 Stream<File>을 Stream<String>으로 변환했다고 볼 수 있다.
	그리고, map()도 filter()처럼 하나의 스트림에 여러번 적용할 수 있다. 다음의 문장은 File의 스트림에서 파일의 확장자만을 
	뽑은 다음 중복을 제거해서 출력한다.
	
	fileStream.map(File::getName) 						// Stream<File> -> Stream<String>		
			  .filter(s->s.index('.') != -1)			// 확장자가 없느 것은 제외
			  .map(s->s.substring(s.indexOf('.')+1))	// Stream<String> -> Stream<String>
			  .map(String::toUpperCase)					// 모두 대문자로 변환
			  .distinct()								// 중복 제거
			  .forEach(System.out::print);				// JAVABAKTXT
			  
	------------------------------------------------------------------------------------------------------------------------
			  
	◈◈◈ 조회 : peek() (예제 StreamEx_3.java)
	연산과 연산 사이에 올바르게 처리되었는지 확인하고 싶을 경우, peek()을 사용하자
	forEach()와 달리 스트림의 요소를 소모하지 않으므로 연산사이에 여러번 끼워넣어도 문제가 되지 않는다.
	
	fileStream.map(File::getName)									// Stream<File> -> Stream<String>
			  .filter(s->s.indexOf('.') != -1)						// 확장자가 없는 것은 제외
			  .peek(s->System.out.printf("fileName = %s%n", s))		// 파일명을 출력
			  .map(s->s.substring(s.indexOf('.')+1))				// 파일 확장자만 추출
			  .peek(s->System.out.printf("extension = %s%n", s))	// 파일 확장자명 출력
			  .forEach(System.out::print);
			  
	filter나 map의 결과를 확인할 때 유용하게 사용될 수 있다. 아래의 예제에는 실행결과가 복잡해지지 않도록 peek을 넣지 않았다.
	직접 peek()을 넣어보고 변경된결과를 확인해보자.
	
	------------------------------------------------------------------------------------------------------------------------
	
	◈◈◈ mapToInt(), mapToLong(), mapToDouble()
	map은 연산 결과로 Stream<T> 타입의 스트림을 반환하는데, 스트림의 요소를 숫자로 변환하는 경우 IntStream과 같은 
	기본형 스트림으로 변환하는 것이 더 유용할 수 있다. Stream<T> 타입의 스트림을 기본형 스트림으로 변환할 때 
	사용하는 것이 아래의 메소이다.
		
		DoubleStream mapToDouble(mapper)
		IntStream 	 mapToInt(mapper)
		LongStream	 mapToLong(mapper)
	
	앞서 사용했던 studentStream에서 스트림에 포함된 모든 학생의 성적을 합산해야 한다면, 
	map으로 학생의 총점을 뽑아서 새로운 스트림을 만들어 낼 수 있다.
	
		Stream<Integer> studentScoreStream = studentStream.map(Student::getTotalScore);
		
	그러나 이럴때는 애초에 mapToInt()를 사용해서 Stream<Integer>가 아닌 IntStream 타입의 스트림을 생성하는 것이 더 효율적이다.
	성적을 더할 때 Integer를 int로 변환할 필요가 없기 때문이다.
		
		IntStream stdScoreStream = stdStream.mapToInt(Student::getTotalScore);
		int allTotScore = stdStream.sum(); // int sum	
		
	count만 지원하는 Stream<T>과 달리 IntStream과 같은 기본형 스트림은 아래와 같이 숫자를 다루는데 편리한 메소드들이 제공된다.
	(※ max(),min()는 Stream에도 제공되지만, Comaparator를 지정해야하는 차이가 있다.)
	
	
		IntStream에서 지원하는 다양한 메소드들
	
		int sum()						// 스트림의 모든 요소의 총합
		OptionalDouble average()		// sum()/(Double)count()
		OptionalDouble max()			// 스트림의 요소 중 제일 큰 값
		OptionalDouble min()			// 스트림의 요소 중 제일 작은 값
	
	스트림의 요소가 하나도 없을 때, sum()은 0을 반환하면 그만이지만 다른 메소드들은 단순히 0을 반환할 수 없다. 
	여러 요소들을 합한 평균이 0일 수 있기 때문이다.
	이를 구분하기 위해 단순히 double값을 반환하는 대신, double 타입의 값을 내부적으로 가지고 있는 OptionalDouble을 반환하는 것이다.
	OptionalInt, OptionalDouble등은 일종의 래퍼클래스로 각각 int, Double값을 내부적으로 갖고있다.
	
	그리고, 이 메소드들은 최종연산이기때문에 호출 후에 스트림이 닫힌다는 점을 주의해야한다. 
	아래 코드와 같이 하나의 스트림에 sum()과 average()를 연속해서 호출할 수 없다.
	
		IntStream scoreStream = stdStream.mapToInt(Student::getTotalScore);
		long totScore = scoreStream.sum(); 					// sum은 최종연산이라 호출 후 스트림이 닫힘
		OptionalDouble average = scoreStream.average(); 	// 에러 스트림 이미 닫힘
		double d= average.getAsDouble(); 					// Optional에 저장된 값 가져옴
	
	sum과 average를 모두 호출해야할 때, 스트림을 또 생성해야하므로 불편하다. 그래서 summaryStatics()라는 메소드가 따로 제공된다.
	
		IntSummaryStatistics stat = scoreStream.summaryStatistics();
		long totCount = stat.getCount();
		long totScore = stat.getSum();
		long avgScore = stat.getAverage();
		int minScore  = stat.getMin();
		int maxScore  = stat.getMax();
	
	IntSummaryStatistics는 위와 같이 다양한 종류의 메소드를 제공하며, 이 중에서 필요한 것만 골라서 사용하면 된다.
	기본형 스트림 LongStream과 DoubleStream도 IntStream과 같은 연산(반환타입은 다름)을 지원한다.
	반대로, IntStream을 Stream<T>로 변환할 때는 mapToObj()를, Stream<Integer>로 변환할때는 boxed()를 사용한다.
		
		Stream<U> mapToObj(IntFunction<? extends U> mapper)
		Stream<Integer> boxed()
	
	아래는 로또번호를 생성해서 출력하는 코드인데, maptoObj()를 이용해서 IntStream을 Stream<String>으로 변환했다.
		
		IntStream intStream = new Random().int(1, 46); // 1~45사이의 정수(46 포함 X)
		Stream<String> lottoStream = intStream.distinct().limit(6).sorted().mapToObj(i -> i + ",");
		lottoStream.forEach(System.out::print); // 10,14,20,23,26,29
		
	참고로, CharSequence에 정의된 chars()는 String이나 StringBuffer에 저장된 문자들을 IntStream으로 다룰 수 있게 해준다.
		
		IntStream charStream = "12345".chars();				// default IntStream chars()
		int charSum = charStream.map(ch -> ch-'0').sum(); 	// charSUm = 15
		
	위 코드에서 사용된 map()은 IntStream에 정의된 것으로 IntStream을 결과로 반환한다.
	그리고, mapToInt()와 함께 자주 사용되는 메소드로는 Integer의 parseInt()나 valueOf()가 있다는 것도 알아두자.
		
		Stream<String>  -> IntStream 변환할 때, mapToInt(Integer::parseInt)
		Stream<Integer> -> IntStream 변환할 때, mapToInt(Integer::intValue)
	
	------------------------------------------------------------------------------------------------------------------------
	
	◈◈◈ flatMap()
	스트림의 요소가 배열이거나 map()의 연산결과가 배열인 경우, 즉 스트림의 타입이 Stream<T[]>인 경우, 
	Stream<T>로 다루는 것이 더 편할 때가 있다. 그때는 map 대신 flatMap을 사용하면 된다.
	
	아래와 같이 요소가 문자열 배열(String[])인 스트림이 있을때
	
		Stream<String[]> stdArrStream = Stream.of(
												new String[]{"abc", "def", "ghi"},
												new String[]{"ABC", "DEF", "GHI"}
												);
												  
	각 요소의 문자열들을 합쳐서 문자열이 요소인 스트림, 즉 Stream<String>으로 만들려면 어떻게 해야 할까?
	먼저 스트림의 요소를 변환해야하니까 일단 map()을 써야할 것이고, 
	여기에 배열을 스트림으로 만들어주는 Arrays.stream(T[])을 함께 사용해보자.
	
		Stream<Stream<String>> strStream = strStream.map(Arrays::stream);
	
	예상과 달리, Stream<String[]>을 map(Arrays::stream)으로 변환한 결과는 Stream<String>이 아닌, 
	Stream<Stream<String>>이다. 즉, 스트림의 스트림인 것이다.
	위 과정은 각 요소의 문자열들이 합쳐지지 않고, 스트림의 스트림 형태로 되어버렸다. 이 때, 간단히
	map()을 아래와 같이 flatMap()을 사용한다면 우리가 원하던 Stream<String[]> -> Stream<String> 형태를 얻을 수 있다.
	
		Stream<Stream<String>> strStrStrm = strArrStrm.map(Arrays::stream);
									
									||||||||||||
									▼▼▼▼▼▼▼▼▼▼▼▼
									 
		Stream<String> strStrm = strArrStrm.flatMap(Arrays::stream);
		
	flatMap()은 map()과 달리, 문자열로 구성된 배열의 스트림을 flatMap을 이용하면 
	스트림의 스트림이 아닌 스트림으로 만들어 준다.
	
	- Stream<String[]> ----------- map(Arrays::stream) 	 ----------->>>>>>>>> Stream<Stream<String>>	
	
	- Stream<String[]> ----------- faltMap(Arrays::stream) ----------->>>>>>>>> Stream<String>
	
	또 다른 경우를 살펴보자.
	아래와같이 여러 문장을 요소로하는 스트림이 있을 때, 이 문장들을 split()으로 나눠서 
	요소가 단어인 스트림을 만들고 싶다면 어떻게 해야할까?
	
		String[] lineArr = {"Belive or not It is true","Do or not There is no try"};
		Stream<String>   lineStrm = Arrays.stream(lineArr);
		Stream<String[]> strArrStream = lineStream.map(line->Stream.of(line.split(" +")));
		
	위의 문장에서 알 수 있는 듯이, map()은 Stream<String>이 아니라 Stream<String[]>을 결과로 반환한다.
	이때, map() 대신 flatMap()으로 원하는 결과를 얻을 수 있다.
		
		Stream<String> strStream = lineStream.flatMap(line->Stream.of(line.split(" +")));
		
	
	이번 예제에서 map()과 flatMap()의 차이는 다음과 같다.
	
	- Stream<String[]> ----------- map(s->Stream.of(s.split(" +"))) 	----------->>>>>>>>> Stream<Stream<String>>	
	
	- Stream<String[]> ----------- flatMap(s->Stream.of(s.split(" +"))) ----------->>>>>>>>> Stream<String>
	
	strStream의 단어들을 모두 소문자로 변환하고, 중복된 단어들을 제거한 다음에 정렬해서 출력하는 문장은 다음과 같다.
	
		strStream.map(String:toLowerCase).distinct().sorted().forEach(System.out::println);
	
	드물지만, 스트림을 요소로하는 스트림, 즉 스트림의 스트림을 하나의 스트림으로 합칠 때도 flatMap()을 사용한다.
	
		Stream<String> strStream  = Stream.of("abc","def", "ghijk"); 
		Stream<String> strStream2 = Stream.of("ABC","DAS", "GHIJK"); 
	
		Stream<Stream<String>> strStrm = Stream.of(strStream, strStream2);
		
	위와 같이 요소의 타입이 Stream<String>인 스트림 Stream<Stream<String>>이 있을때, 이 스트림을 Stream<String>으로 
	변환하려면 다음과 같이 map()과 flatMap()을 함께 사용해야한다.
		
		Stream<String> strStrm = strmStrm
								 .map(s->s.toArray(String[]::new))	// Stream<Stream<String>> -> Stream<String[]>
								 .flatMap(Arrays::stream);			// Stream<String[]> -> Stream<String>
	
	toArray()는 스트림을 배열로 변환해서 반환한다. 매개변수를 지정하지 않으면 Object[]을 반환하므로 
	위와 같이 특정 타입의 생성자를 지정해줘야 한다. 여기서는 String 배열의 생성자(String[]::new)를 지정하였다.
	그 다음엔 flatMap()으로 Stream<String[]>을 Stream<String>으로 변환한다.
	
	
	2.5 최종연산
	최종 연산은 스트림의 요소를 소모해서 결과를 만들어낸다. 그래서 최종 연산후에는 
	스트림이 닫히게되고 더 이상 사용할 수 없다.	최종 연산의 결과는 스트림 요소의 합과 같은 단일 값이거나, 
	스트림의 요소가 담긴 배열 또는 컬렉션일 수 있다.
	 forEach()나 count() 같은 최종 연산의 일부는 이미 소개했으며, collect()도 최종연산이지만, 그 내용이 복잡하여 별도 단원으로
	분리하였다.
	
	------------------------------------------------------------------------------------------------------------------------
	
	- Optional<T> & OptionalInt
	최종연산의 결과가 타입이 Optional인 경우가 있다.
	Optional<T>는 제네릭 클래스로 'T 타입의 객체'를 감싸는 래퍼 클래스이다. 
	그래서 Optional 타입의 객체에는 모든 타입의 참조변수를 담을 수 있다.
	
	ex)	public final class Optional<T>{
			private final T value; // T타입의 참조변수 
		}
	최종 연산의 결과를 그냥 반환하는게 아니라 optional 객체에 담아서 반환하는 것이다. 이처럼 객체에 담아서 반환하며, 
	반환된 결과가 null인지 매번 if문으로체크하는 대신 Optonal에 정의된 메소드를 통해서 간단히 처리할 수 있다.
	(※ Object 클래스의 isNull(), nonNull(), requireNonNull()과 같은 메소드가 있는 것도 널 체크를 위한 
	   if 문을 메소드 안으로 넣어서 코드 복잡도를 낮추기 위한 것이다.)	
	   
	* Optional 객체 생성하기
	Optional 객체를 생성할때는 of() 또는 OfNullable()을 사용한다.
	
		String str = "str";
	
		Optional<String> optVal = Optional.of(str);
		Optional<String> optVal = Optional.of("abc");
		Optional<String> optVal = Optional.of(new String("abc"));
	
	만일 참조변수의 값이 null일 가능성이 있으면, of() 대신 ofNullable()을 사용해야 한다.
	of()는 매개변수의 값이 null이면 NullPointerException이 발생하기 때문이다.
		
		Optional<String> optVal = Optional.of(null);			// NullPointerException 발생
		Optional<String> optVal = Optional.ofNullable(null);	// OK
		
	Optional<T>타입의 참조변수를 기본값으로 초기화할 때는 empty()를 사용한다. null로 초기화하는 것이 가능하지만,
	empty()로 초기화하는 것이 바람직하다.
	※ empty()는 지네릭 메소드라서 앞에 <T>를 붙였다. 추정가능하므로 생략가능하다.

		Optional<String> optVal = null; // null 로 초기화	
		Optional<String> optVal = Optional.<String>empty(); // 빈 객체로 초기화	
	
	* Optional 객체의 값 가져오기
	Optional 객체에 저장된 값을 가져올 때는 get()을 사용한다. 값이 null일 경우 NoSuchElementException이 발생하며, 
	이를 대비하기 위해 orElse()로 대체값을 지정할 수 있다.
		Optional<String> optVal = Optional.of("abc");
		String str1 = optVal.get();				// optVal에 저장된 값 반환, null이면 예외발생...
		String str2 = optVal.orElse("");		// optVal 저장된 값이 null이면 ""을 반환
	
	orElse()의 변형으로는 null을 대체할 값을 반환하는 람다식을 지정할 수 있는 orElseGet()과 null일 때 지정된 예외를
	발생시키는 orElseThrow()가 있다.
		ex)
		String str3 = optVal12.orElseGet(String::new);					// ()->new String()과 동일
		String str4 = optVal12.orElseThrow(NullPointerException::new);	// null이면 예외 발생
	
	Stream 처럼 Optional객체에도 filter(), map(), flatMap()을 사용할 수 있다. map()의 연산결과가 Optional<Optional<T>>일 때,
	flatMap()을 사용하면 Optional<T>를 결과로 얻는다. 만일 Optional객체의 값이 null이면, 이 메소드들은 아무 일도 하지 않는다.
	
		int result = Optional.of("123").filter(x -> x.length() > 0)
							 .map(Integer::parseInt()).orElse(-1); 	// 결과: result = 123;
	
	
		result = Optional.of("").filter(x->x.length() > 0)
								.map(Integer::parseInt()).orElse(-1); // 결과: result = -1
	
	우리가 이미 알고 있는 것처럼 parseInt()는 예외가 발생하기 쉬운 메소드이다. 만일 예외처리된 메소드를 만들면 아래와 같다.
		
		static int optStrToInt(Optional<String> optStr, int defaultValue){
			try{
				return optStr.map(Integer::parseInt()).get();
			}catch(Exception e){
				return defaultValue;
			}
		}
	
	isPresent()는 Optional 객체의 값이 null이면 false를, 아니면 true를 반환한다. ifPresent(Consumer<T> block)은 값이 있으면
	주어진 람다식을 실행하고 없으면 아무일도 하지 않는다. 
	
		if(str!=null){
			System.out.println(str);
		}
	
	만일 위와 같은 조건문이 있다면 isPresent()를 이용해서 다음과 같이 쓸 수 있다.
		
		if(Optional.ofNullable(str).isPresent()){
			System.out.println(str);
		}
		
	이 코드를 ifPresent()를 이용해서 바꾸면 더 간단히 할 수 있다. 아래 문장은 참조변수 str이 null이 아닐때만 값을 출력하고,
	null 이면 아무 일도 일어나지 않는다.
		
		Optional.ofNullable(str).isPresent(System.out::println); 
	
	ifPresent()는 Optional<T>를 반환하는 findAny()나 findFirst()와 같은 최종 연산과 잘 어울린다.
	Stream 클래스에 정의된 메소드 중에서 Optional<T>를 반환하는 것들은 다음과 같다.
		Optional<T> findAny()
		Optional<T> findFirst()
		Optional<T> max(Comparator<? super T> comparator)
		Optional<T> min(Comparator<? super T> comparator)
		Optional<T> reduce(BinaryOptional<T> accumulator)
	
	이처럼 Optional<T>를 결과로 반환하는 최종 연산 메소드는 몇 개 없다. 심지어 max()와 min()같은 메소드들은 
	reduce()를 이용해서 작성된 것이다.
	
	* OptionalInt, OptionalLong, OptionalDouble
	IntStream과 같은 기본형 스트림에는 Optional도 기본형을 값으로 하는 OptionalInt, OptionalLong, OptionalDouble을 반환한다.
	아래의 목록은 IntStream에 정의된 메소드들이다.
		
		OptionalInt 	findAny()
		OptionalInt 	findFirst()
		OptionalInt 	reduce(IntBinaryOperator op)
		OptionalInt 	max()
		OptionalInt 	min()
		OptionalDouble 	average()
		
	반환 타입이 Optional<T>가 아니라는 것을 제외하고는 Stream에 정의된 것과 비슷하다.
	그리고 기본형 Optional에 저장된 값을 꺼낼 때 사용하는 메소드의 이름이 조금씩 다르다는 것을 주의하자.
		
		ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
		Optional 클래스			|	값을  반환하는 메소드
		ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
		Optional<T>				|	T get()
		OptionalInt				|	int getAsInt()
		OptionalLong			|	long getAsLong()
		OptionalDouble			|	double getAsDouble()
		ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	
	OptionalInt는 다음과 같이 정의되어 있다. 앞서 래퍼 클래스에 대해서 배웠으므로, 이렇게 정의되어 있을 것이라고
	짐작하는 것은 그리 어려운 일이 아니다.
		
		public final class OptionalInt{
			...
			private final boolean isPresent;	// 값이 저장되어 있으면 true
			private final int value;			// int 타입의 변수
			...
		}	
	기본형 int의 기본값은 0이므로 아무런 값도 갖지 않는 OptionalInt에 저장되는 값은 0일 것이다.
	그러면 아래의 두 OptionalInt 객체는 같은 것일까?
		
		OptionalInt opt  = OptionalInt.of(0);		// OptionalInt에 0 저장
		OptionalInt opt2 = OptionalInt.empty();		// OptionalInt에 0 저장
		
	다행히 저장된 값이 없는 것과 0이 저장된 것은 isPresent라는 인스턴스 변수로 구분이 가능하다. 
	isPresent()는 이 인스턴스 변수의 값을 반환한다.
		
		System.out.println(opt.isPresent());	// true
		System.out.println(opt2.isPresent());	// false
		
		System.out.println(opt.getAsInt());		// 0
		System.out.println(opt2.getAsInt());	// NoSuchElementException 예외발생
		
		System.out.println(opt.equals(opt2));	// false
	
	그러나 Optional 객체의 경우 Null을 저장하면 비어있는 것과 동일하게 취급한다.
		
		Optional<String> opt  = Optional.ofNullable(null);
		Optional<String> opt2 = Optional.empty();
		
		System.out.println(opt.equals(opt2));			// true
		
	위의 내용을 예제로 확인하자. ( -> StreamEx_4.java)
	
	------------------------------------------------------------------------------------------------------------------------
	
	- forEach()
	
	forEach()는 peek()과 달리 스트림의 요소를 소모하는 최종연산이다. 반환 타입이 void 이므로 스트림의 요소를 출력하는 
	용도로 많이 사용된다. 

		void forEach(Consumer<? super T> action)
		
	------------------------------------------------------------------------------------------------------------------------
	
	- 조건검사(스트림 요소) allMatch(), anyMatch(), noneMatch(), firstFind(), findAny()
	
	 스트림의 요소에 대해 지정된 조건에 모든 요소가 일치하는 지, 일부가 일치하는지 아니면 어떤 요소도 일치하지 않는지 
	확인하는데 사용할 수 있는 메소드들이다. 이 메소드는 모두 매개변수로 Predicate를 요구하며, 연산결과로 boolean을 반환한다.
	
		boolean allMatch (Predicate<? super T> predicate)
		boolean anyMatch (Predicate<? super T> predicate)
		boolean noneMatch(Predicate<? super T> predicate)
	
	예를 들어 학생들의 성적 정보 스트림 strStream에서 총점이 낙제점(총점 100이하)인 학생의 존재여부 검사는 다음과 같다.
	
		boolean noFailed = stuStream.anyMatch(s->s.getTotalScore() <= 100);
	
	이외에도 스트림의 요소 중에서 조건에 일치하는 첫 번째 것을 반환하는 findFirst()가 있는데, 주로 filter()와 함께 사용되어
	조건에 맞는 스트림의 요소가 있는지 확인하는데 사용된다. 병렬 스트림의 경우에는 findFirst() 대신 findAny()를 사용해야 한다.
	
		Optional<Student> stu  = stuStream.filter(s->s.getTotalScore() <= 100).findFirst();
		Optional<Student> stu2 = parallelStream.filter(s->s.getTotalScore() <= 100).findAny();
	
	findAny()와 findFirst()의 반환 타입은 Optional<T> 이며, 스트림의 요소가 없을 때는 비업있는 Optional객체를 반환한다.
	※) 비어있는 optional 객체는 내부적으로 null을 저장하고 있다.

	------------------------------------------------------------------------------------------------------------------------
	
	- 통계 count() , sum(), average(), max(), min()
	
	앞서 살펴본 것처럼 IntStream과 같은 기본형 스트림에는 스트림의 요소들에 대한 통계 정보를 얻을 수 있는 메소드가 있다.
	그러나 기본형 스트림이 아닌 경우에는 통계와 관련된 메소드들이 아래의 3개 뿐이다.
	※) 기본형 스트림의 min(), max()와 달리 매개변수로 Caomparator를 필요로 한다는 차이가 있다.
	
		long count()
		Optional<T> max(Comparator<? super T> comparator)
		Optional<T> min(Comparator<? super T> comparator)
		
	대부분의 경우 위 메소드를 사용하기보다 기본형 스트릠으로 변환하거나, 아니면 앞으로 배우게될 reduce()와 collect()를 
	사용해서 통계정보를 얻는다.
	
	------------------------------------------------------------------------------------------------------------------------

	- reduce() 리듀싱 (예제 -> StreamEx_5.java)
	
	reduce()는 스트림의 요소를 줄여나가면서 연산을 수행하고 최종결과를 반환한다. 그래서 매개변수의 타입이 
	BinaryOperator<T>인 것이다. 처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다.
	이 과정에서 스트림의 요소를 하나씩 소모하게 되며, 스트림의 모든 요소를 소모하게 되면 그 결과를 반환한다.
	
		Optional<T> reduce(BinaryOperator<T> accumulator)
		
	이외에도 연산결과의 초기값(identity)을 갖는 reduce()도 있는데, 이 메소드들은 초기값과 스트림의 첫번쨰 요소로 연산을 시작한다.
	스트림의 요소가 하나도 없는 경우, 초기값이 반환되므로 반환 타입이 Optional<T>가 아니라 T이다.
	※)BinaryOperator<T>는 BiFunction의 자손이며, BiFunction<T,T,T>와 동등하다.
	
		T reduce(T identity, BinaryOperator<T> accumulator)
		U reduce(U identity, BiFunction<T,T,T> accumulator, BinaryOperator<U> combiner)
	
	위의 두번쨰 메소드의 마지막 매개변수인 combiner는 병렬 스트림에 의해 처리된 결과를 합칠 때 사용하기 위해 사용하는 것이며,
	후에 병렬 스트림에서 소개할 예정이다.
	앞서 소개한 최종 연산 count(), sum() 등은 내부적으로 모두 reduce()를 이용해서 아래와 같이 작성된 것이다.
		
		int count 	= intStream.reduce(0, (a,b) -> a+1); 	// count()
	 	int sum		= intStream.reduce(0, (a,b) -> a+b);  	// sum()
	 	int max		= intStream.reduce(Integer.MIN_VALUE, (a,b) -> a>b?a:b);  	// max()
	 	int min		= intStream.reduce(Integer.MAX_VALUE, (a,b) -> a<b?a:b);  	// min()
	 
	 사실 max()와 min()의 경우, 초기값이 필요없으므로 Optional<T>를 반환하는 매개변수 하나짜리 reduce()를 사용하는 것이 낫다.
	 단 intStream의 타입이 IntStream인 경우 OptionalInt를 사용해야 한다. Stream<T>와 달리 IntStream에 정의된 reduce()의 반환
	 타입이 Optionalint이기 때문이다.
	 
	 	OptionalInt max = intStream.reduce((a,b) -> a>b?a:b); // max()
	 	OptionalInt min = intStream.reduce((a,b) -> a<b?a:b); // min()
	 
	 위의 문장들에서 람다식을 Integer클래스의 static 메소드 max()와 min()을 이용해서 메소드 참조로 바꾸면 다음과 같다.
	 
	 	OptionalInt max = intStream.reduce(Integer::max); // int max(int a, int b)
	 	OptionalInt min = intStream.reduce(Integer::min); // int min(int a, int b)
	 
	 그리고 OptionalInt에 저장된 값을 꺼내는 과정은 아래와 같다.
	 
	 	int maxVal = max.getAsInt(); // OptionalInt에 저장된 값을 maxValue로 저장
	 	
	 reduce()가 내부적으로 어떻게 동작하는지 이해를 돕기 위해, reduce()로 스트림의 모든 여소를 다 더하는 과정을 for문으로 표현.
	 
	 	int a = identity;	// 초기값을 a에 저장
	 	for(int b : stream)
	 		a = a+b;			// 모든 요소의 값을 a에 누적
	 
	 위의 for문을 보고 나면, reduce()가 아마도 다음과 같이 작성되어있을 것이다.

	 	T reduce(T identity, BinaryOperator<T> accumulator){
	 		T a = identity;

	 		for(T b : stream)
	 			a = accumulator.apply(a,b);
	 			
	 		return a;
	 	}
	 	
	 reduce()를 사용하는 방법은 간단한다. 그저 초기값을(identity)과 어떤 연산(BinaryOperator)으로 스트림의 요소를 줄여나갈
	 것인지만 결정하면 된다.
	 
	------------------------------------------------------------------------------------------------------------------------	
	
	- collect()
	 collect()는 스트림의 요소를 수집하는 최종연산으로 앞서 배운 리듀싱(reducing)과 유사하다.
	collect()가 스트림의 요소를 수집하려면, 어떻게 수집할 것인가에 대한 방법이 정의되어있어야 하는데,
	이 방법을 정의한것이 바로 컬렉터(collector)이다.
	컬렉터는 Collector 인터페이스를 구현한 것으로, 직접 구현할 수도 있고, 미리 작성된 것을 사용할 수도 있다.
	Collectors 클래스는 미리 작성된 다양한 종류의 컬렉터를 반환하는 static 메소드를 가지고 있으며, 
	이클래스를 통해 제공되는 컬렉터만으로도 많은 일들을 할 수 있다.
	
		collect() 스트림의 최종연산, 매개변수롤 컬렉터를 필요로 한다.
		Collector 인터페이스, 컬렉터는 이 인터페이스를 구현해야한다.
		Collectors 클래스, static 메소드로 미리 작성된 컬렉터를 제공한다.
	
	Collector 인터페이스를 직접 구현해서 컬렉터를 만드는 방법은 차후 배울것이며,
	이번에는 Collectors 클래스가 제공하는 컬렉터들을 사용하는 방법에 대해서 알아볼 것이다.
	
 	p845 차례
	
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	------------------------------------------------------------------------------------------------------------------------	