[스트림]

구조
1. 스트림 생성
2. 중개연산
3. 최종연산

-> 표기 : Collections 객체집합.스트림생성().중개연산().최종연산();
-> 대상 : collection, arrays, IO resource(ex-File), Generators, stream ranges, pattern 등


2. 중개 연산

	2.1) Filter - 조건에 맞는 것만 거른다. 
		List<String> names = Arrays.asList("AAA", "ABA", "ACA");
		Stream<String> nameStream = names.stream().filter(x -> x.contains("C"));
		결과 : nameStream에는 "C"가 포함된 "ACA"만 갖고 있는 스트림을 반환한다.
	
	2.2) Map - 스트림의 각 요소를 연산할 때 사용
		List<String> names = Arrays.asList("jeong", "pro", "jdk", "java");
		names.parallelStream().map((x)-> {return x.concat("s");}).forEach(x -> System.out.println(x));
		결과 : 리스트 각 요소에 s를 붙여서 하나씩 출력 "jeongs", "pros", "jdks", "javas"
	
	2.3) Peek - map()과 같이 각 요소에 연산 적용 시 사용
		
	2.4) Sorted 스트림 요소 정렬	
	
	2.5) Limit - 스트림 요소의 크기를 지정(선입 기준)
		List<Integer> ages = Arrays.asList(1,2,3,4,5,6,7,8,9);
		Stream<Integer> numbers = ages.stream().filter(x -> x>3).limit(3);
		결과 : 4, 5, 6을 가진 스트림 반환 (7,8,9는 없음)
	
	2.6) Distinct - 스트림의 요소 중복 제거 ex - 1,2,1,2,1,2,1,2 -> 1, 2 스트림 반환  
	
	2.7) Skip - 처음 skip 개수를 제외한 나머지 요소의 스트림 반환
	
	2.8) mapToInt, mapToLong, mapToDouble...
		mapXXXX 함수는 해당 타입(XXXX)의 스트림으로 변경한다. 
		ex) "1", "2", "3"의 스트림을 mapToInt 적용시 1,2,3을 가진 스트림으로 변환 한다.


3. 최종 연산

	3.1) count(), min(), max(), sum(), average()
		위의 함수(중개)를 적용했던 스트림에 있는 요소들의 count, sum 등의 결과를 얻을 수 있는 함수이다.
	
	3.2) reduce() - 누적된 값을 계산한다.
		List<Integer> ages = new ArrayList<Integer>();
		ages.add(1);
		ages.add(2);
		ages.add(3);
		
		System.out.println( ages.stream().reduce((b,c)->b+c).get() ); // 1+2+3
		
		-> b, c로 지정한 파라미터를 가지고 리턴한 결과(b+c)가 다시 b가 되고, 
		다음 스트림의 요소가 c가 되어 계속 누적된다. 
		
	3.3) forEach - map, peek의 최종 연산버전이다. 각 요소를 돌면서 처리할 수 있도록 되어있다.
		List<Integer> ages = new ArrayList<Integer>();
		ages.add(1);
		ages.add(2);
		ages.add(3);
		
		Set<Integer> set = ages.stream().collect(Collectors.toSet());
		set.forEach(x -> System.out.println(x)); 
		// 1, 2, 3
		
	3.4) collect - collect는 스트림의 값들을 모아주는 기능으로 toMap, toSet, toList로 해당 스트림을 다시 컬렉션으로 바꾼다.
	
	3.5) iterator - 스트림을 iterator<T>를 반환
		List<String> names = Arrays.asList("jeong", "pro", "jdk", "java");
		Iterator<String> iter =  names.stream().iterator();
		while(iter.hasNext()) System.out.println(iter.next()); // "jeong", "pro", "jdk", "java" 
	
	3.6) noneMathch - 최종적으로 얻은 스트림의 '모든' 요소들이 조건을 만족하지 '않는'지를 판단하여 boolean 리턴 
		 anyMatch - 스트림의 요소들 중에 하나라도 조건을 만족하는지 판단해서 boolean 리턴 
		 allMatch - 스트림의 '모든' 요소들이 존건을 만족하는지 판단하여 boolean 리턴
		 
		List<Integer> ages = new ArrayList<Integer>();
		ages.add(1);
		ages.add(2);
		ages.add(3);
		System.out.println(ages.stream().filter(x -> x>1).nonMatch(x -> x>2)); // false 
		
	
4. 주의사항

4.1) 스트림은 재사용 불가능하다.
	Stream<String> a = names.stream().filter(x -> x.contains("A"));
	int count = a.count();
	
	List<String> lists = a.collect(Collectors.toList());
	// 사용했던 a를 재사용할 경우 Exception 발생
	
	
4.2) 병렬 스트림은 여러 쓰레드가 작업한다.

names.parallelStream().filter(x -> x.contains("o")).count();

-> stream()으로 스트림을 생성하는 경우와 달리 parallelStream()을 이용하면 병렬 스트림을 만들 수 있다.
이렇게하면 여러 쓰레드가 스트림에서 요소를 필터링하고 나온 요소 수를 계산하고 
쓰레드끼리 다시 한 번 각자 계산한 count 값들을 더해서 리턴해준다.
단순하게 생각하면 여러쓰레드가 처리해주니 병렬스트림이 항상 성능면에서 유리해보일 수 있지만 
애플리케이션에서 사용하는 쓰레드가 많거나 스트림의 요소 수가 많지 않다면 
오히려 쓰레드를 사용하는데 드는 오버헤드가 더 클 수도 있다.


4.3) 중개 연산은 미리하지 않는다 지연 연산을 한다(loop 작업은 한번에 처리하는 것을 지향).

Stream<String> a = names.stream().filter(x -> x.contains("o")).map(x-> x.concat("s"));
a.forEach(x -> System.out.println(x));

위와 같은 코드가 있으면 위에 filter와 map 함수는 미리 계산하고 있지 않고 있다가 
forEach와 같은 최종연산이 적용될 때 중개 연산도 실행된다.
이로써 얻는 장점은 미리 계산하면서 두 번 순회하는 짓을 안할 수 있게 된다는 점이다.

출처: https://jeong-pro.tistory.com/165 [기본기를 쌓는 정아마추어 코딩블로그]
	
		
		
		